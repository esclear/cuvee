Achieve first results:
1. get fusion right
2. get function matching right
3. implement main loop
4. check which proofs work with base case factoring and promotion

Further work
1. find liftings (promotions) automatically
2. parse full TIP, maybe Haskell?

New
1. monomorphic identity functions
2. prepare promotion queries for Grigory
3. fix lemma recovery, perhaps using E-Graphs?
4. implement argument promotion



Argument factoring
- find out when we can drop guards, because "nil" is not actually looked at and can in fact be arbitrary (a parameter?)
- more specifically, can we just drop cases when the forward compuation is not looked at any more?

Guard factoring
- can we split a function into which of its base cases is triggered? drop/take. Note: more complex when not having linear recursion
- analogously: can we fix a particular path through the execution, e.g., always take case 1)

Sidecomputation factoring:
- can we lift b and c separately? they are independent and should combine modularly (i.e. commute)
- what's the correct condition? a single recursive case? linear recursion?

Look at examples:

map_take:    (getting rid of guards) can we express the param as a map by factoring the arguments to the recursive call?
length_drop: (getting rid of matched argument) can we synthesis "-" for the argument?
length_take: observe that some *partial* computation is given by length

forall n: Nat. (length_drop_0(n, nil) = zero)
forall xs: List[Elem]. (length_drop_0(zero, xs) = length(xs))
forall n: Nat, y: Elem, ys: List[Elem]. (length_drop_0(succ(n), cons(y, ys)) = length_drop_0(n, ys))

New idea: guard fusion:
- assuming a recursive predicate that holds, can we specialize a function wrt. this premise?

We can do this:

- fuse f.g into f_g (for a particular argument of matching type)
- factor the base case of any function
- simplify definitions (when and what are good rules?)
- inward mapping  = normalization
- outward mapping = reverse normalization lemmas

Synthesis strategy:

- triggered 
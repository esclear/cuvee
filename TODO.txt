May 27

- integrate promotion for length, contains
- map is still pending
- check reverse snoc
- recognize identity function and apply lemma
- recognizing negated functions
- fix fusion
- is the order of functions relevant?
- write up stuff

Achieve first results:
1. get fusion right
2. get function matching right
3. implement main loop
4. check which proofs work with base case factoring and promotion

Further work
1. find liftings (promotions) automatically
2. parse full TIP, maybe Haskell?

Done
- conclude the special case for remove, which yields append(x1, nil) = x1 

New
1. monomorphic identity functions
2. prepare promotion queries for Grigory
3. fix lemma recovery, perhaps using E-Graphs?
4. implement argument promotion
5. fix recognizing the identiry function (monomorphic)
6. known modulo reordering of cases and parameters

Boolean stuff: remove'_pre₁'? vs contains'

map_take == take_ map modulo reordering of parameters

We want to generate such monstrosities on-demand, or perhaps leave this as future work
  take_take_1'(zero, zero, nil, z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₂₈
  take_take_1'(succ(n), zero, nil, z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₂₉
  take_take_1'(zero, zero, cons(y, ys), z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₃₀
  take_take_1'(succ(n), zero, cons(y, ys), z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₃₁
  take_take_1'(zero, succ(n), nil, z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₃₂
  take_take_1'(succ(n₂₄), succ(n), nil, z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₃₃
  take_take_1'(zero, succ(n), cons(y, ys), z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = z₃₄
  take_take_1'(succ(n₂₅), succ(n), cons(y, ys), z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄) = cons(y, take_take_1'(n₂₅, n, ys, z₂₈, z₂₉, z₃₀, z₃₁, z₃₂, z₃₃, z₃₄))
  take_take_1(x₀, x₁, x₂) = take_take_1'(x₀, x₁, x₂, nil, nil, nil, nil, nil, nil, nil)


Argument factoring
- find out when we can drop guards, because "nil" is not actually looked at and can in fact be arbitrary (a parameter?)
- more specifically, can we just drop cases when the forward compuation is not looked at any more?

Guard factoring
- can we split a function into which of its base cases is triggered? drop/take. Note: more complex when not having linear recursion
- analogously: can we fix a particular path through the execution, e.g., always take case 1)

Sidecomputation factoring:
- can we lift b and c separately? they are independent and should combine modularly (i.e. commute)
- what's the correct condition? a single recursive case? linear recursion?

Look at examples:

map_take:    (getting rid of guards) can we express the param as a map by factoring the arguments to the recursive call?
length_drop: (getting rid of matched argument) can we synthesis "-" for the argument?
length_take: observe that some *partial* computation is given by length

forall n: Nat. (length_drop_0(n, nil) = zero)
forall xs: List[Elem]. (length_drop_0(zero, xs) = length(xs))
forall n: Nat, y: Elem, ys: List[Elem]. (length_drop_0(succ(n), cons(y, ys)) = length_drop_0(n, ys))

New idea: guard fusion:
- assuming a recursive predicate that holds, can we specialize a function wrt. this premise?

We can do this:

- fuse f.g into f_g (for a particular argument of matching type)
- factor the base case of any function
- simplify definitions (when and what are good rules?)
- inward mapping  = normalization
- outward mapping = reverse normalization lemmas

Synthesis strategy:

- triggered 